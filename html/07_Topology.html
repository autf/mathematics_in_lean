<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>7. Topology &mdash; Mathematics in Lean 0.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Index" href="genindex.html" />
    <link rel="prev" title="6. Abstract Algebra" href="06_Abstract_Algebra.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Mathematics in Lean
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="01_Introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_Basics.html">2. Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_Logic.html">3. Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_Sets_and_Functions.html">4. Sets and Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="05_Number_Theory.html">5. Number Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="06_Abstract_Algebra.html">6. Abstract Algebra</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">7. Topology</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#filters">7.1. Filters</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="genindex.html">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Mathematics in Lean</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li><span class="section-number">7. </span>Topology</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/07_Topology.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <span class="target" id="topology"></span><section id="index-0">
<span id="id1"></span><h1><span class="section-number">7. </span>Topology<a class="headerlink" href="#index-0" title="Permalink to this heading">&#61633;</a></h1>
<p>Calculus is based on the concept of a function, which is used to model
quantities that depend on one another.
For example, it is common to study quantities that change over time.
The notion of a <em>limit</em> is also fundamental.
We may say that the limit of a function <span class="math notranslate nohighlight">\(f(x)\)</span> is a value <span class="math notranslate nohighlight">\(b\)</span>
as <span class="math notranslate nohighlight">\(x\)</span> approaches a value <span class="math notranslate nohighlight">\(a\)</span>,
or that <span class="math notranslate nohighlight">\(f(x)\)</span> <em>converges to</em> <span class="math notranslate nohighlight">\(b\)</span> as <span class="math notranslate nohighlight">\(x\)</span> approaches <span class="math notranslate nohighlight">\(a\)</span>.
Equivalently, we may say that a <span class="math notranslate nohighlight">\(f(x)\)</span> approaches <span class="math notranslate nohighlight">\(a\)</span> as <span class="math notranslate nohighlight">\(x\)</span> approaches a value <span class="math notranslate nohighlight">\(b\)</span>, or that it <em>tends to</em> <span class="math notranslate nohighlight">\(b\)</span>
as <span class="math notranslate nohighlight">\(x\)</span> tends to <span class="math notranslate nohighlight">\(a\)</span>.
We have already begun to consider such notions in <a class="reference internal" href="03_Logic.html#sequences-and-convergence"><span class="std std-numref">Section 3.6</span></a>.</p>
<p><em>Topology</em> is the abstract study of limits and continuity.
In this chapter, we will see how topological notions are formalized in mathlib.
Not only do topological abstractions apply in much greater generality,
but that also, somewhat paradoxically, make it easier to reason about limits
and continuity in concrete instances.</p>
<p>Topological notions build on quite a few layers of mathematical structure.
The first layer is naive set theory,
as described in <a class="reference internal" href="04_Sets_and_Functions.html#sets-and-functions"><span class="std std-numref">Chapter 4</span></a>.
The next layer is the theory of <em>filters</em>, which we will describe in <a class="reference internal" href="#filters"><span class="std std-numref">Section 7.1</span></a>.
On top of that, we layer
the theories of <em>topological spaces</em>, <em>metric spaces</em>, and a slightly more exotic
intermediate notion called a <em>uniform space</em>.</p>
<p>Whereas previous chapters relied on mathematical notions that were likely
familiar to you,
the notion of a filter less well known,
even to many working mathematicians.
The notion is essential, however, for formalizing mathematics effectively.
Let us explain why.
Let <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">&#8477;</span> <span class="pre">&#8594;</span> <span class="pre">&#8477;</span></code> be any function. We can consider
the limit of <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code> as <code class="docutils literal notranslate"><span class="pre">x</span></code> approaches some value <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code>,
but we can also consider the limit of <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code> as <code class="docutils literal notranslate"><span class="pre">x</span></code> approaches infinity
or negative infinity.
We can moreover consider the limit of <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code> as <code class="docutils literal notranslate"><span class="pre">x</span></code> approaches <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code> from
the right, conventionally written <code class="docutils literal notranslate"><span class="pre">x&#8320;&#8314;</span></code>, or from the left,
written  <code class="docutils literal notranslate"><span class="pre">x&#8320;&#8315;</span></code>. There are variations where <code class="docutils literal notranslate"><span class="pre">x</span></code> approaches <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code> or <code class="docutils literal notranslate"><span class="pre">x&#8320;&#8314;</span></code>
or <code class="docutils literal notranslate"><span class="pre">x&#8320;&#8315;</span></code> but
is not allowed to take on the value <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code> itself.
This results in at least eight ways that <code class="docutils literal notranslate"><span class="pre">x</span></code> can approach something.
We can also restrict to rational values of <code class="docutils literal notranslate"><span class="pre">x</span></code>
or place other constraints on the domain, but let&#8217;s stick to those 8 cases.</p>
<p>We have a similar variety of options on the codomain:
we can specify that <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code> approaches a value from the left or right,
or that it approaches positive or negative infinity, and so on.
For example, we may wish to say that <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code> tends to <code class="docutils literal notranslate"><span class="pre">+&#8734;</span></code>
when <code class="docutils literal notranslate"><span class="pre">x</span></code> tends to <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code> from the right without
being equal to <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code>.
This results in 64 different kinds of limit statements,
and we haven&#8217;t even begun to deal with limits of sequences,
as we did in <a class="reference internal" href="03_Logic.html#sequences-and-convergence"><span class="std std-numref">Section 3.6</span></a>.</p>
<p>The problem is compounded even further when it comes to the supporting lemmas.
For instance, limits compose: if
<code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code> tends to <code class="docutils literal notranslate"><span class="pre">y&#8320;</span></code> when <code class="docutils literal notranslate"><span class="pre">x</span></code> tends to <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code> and
<code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">y</span></code> tends to <code class="docutils literal notranslate"><span class="pre">z&#8320;</span></code> when <code class="docutils literal notranslate"><span class="pre">y</span></code> tends to <code class="docutils literal notranslate"><span class="pre">y&#8320;</span></code> then
<code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">&#8728;</span> <span class="pre">f</span> <span class="pre">x</span></code> tends to <code class="docutils literal notranslate"><span class="pre">z&#8320;</span></code> when <code class="docutils literal notranslate"><span class="pre">x</span></code> tends to <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code>.
There are three notions of &#8220;tends to&#8221; at play here,
each of which can be instantiated in any of the eight ways described
in the previous paragraph.
This results in 512 lemmas, a lot to have to add to a library!
Informally, mathematicians generally prove two or three of these
and simply note that the rest can be proved &#8220;in the same way.&#8221;
Formalizing mathematics requires making the relevant notion of &#8220;sameness&#8221;
fully explicit, and that is exactly what Bourbaki&#8217;s theory of filters
manages to do.</p>
<section id="filters">
<span id="index-1"></span><span id="id2"></span><h2><span class="section-number">7.1. </span>Filters<a class="headerlink" href="#filters" title="Permalink to this heading">&#61633;</a></h2>
<p>A <em>filter</em> on a type <code class="docutils literal notranslate"><span class="pre">X</span></code> is a collection of sets of <code class="docutils literal notranslate"><span class="pre">X</span></code> that satisfies three
conditions that we will spell out below. The notion
supports two related ideas:</p>
<ul class="simple">
<li><p><em>limits</em>, including all the kinds of limits discussed above: finite and infinite limits of sequences, finite and infinite limits of functions at a point or at infinity, and so on.</p></li>
<li><p><em>things happening eventually</em>, including things happening for large enough <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">:</span> <span class="pre">&#8469;</span></code>, or sufficiently near a point <code class="docutils literal notranslate"><span class="pre">x</span></code>, or for sufficiently close pairs of points, or almost everywhere in the sense of measure theory. Dually, filters can also express the idea of <em>things happening often</em>: for arbitrarily large <code class="docutils literal notranslate"><span class="pre">n</span></code>, at a point in any neighborhood of given a point, etc.</p></li>
</ul>
<p>The filters that correspond to these descriptions will be defined later in this section, but we can already name them:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">(at_top</span> <span class="pre">:</span> <span class="pre">filter</span> <span class="pre">&#8469;)</span></code>, made of sets of <code class="docutils literal notranslate"><span class="pre">&#8469;</span></code> containing <code class="docutils literal notranslate"><span class="pre">{n</span> <span class="pre">|</span> <span class="pre">n</span> <span class="pre">&#8805;</span> <span class="pre">N}</span></code> for some <code class="docutils literal notranslate"><span class="pre">N</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&#120029;</span> <span class="pre">x</span></code>, made of neighborhoods of <code class="docutils literal notranslate"><span class="pre">x</span></code> in a topological space</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&#120036;</span> <span class="pre">X</span></code>, made of entourages of a uniform space (uniform spaces generalize metric spaces and topological groups)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&#956;.a_e</span></code> , made of sets whose complement has zero measure with respect to a measure <code class="docutils literal notranslate"><span class="pre">&#956;</span></code>.</p></li>
</ul>
<p>The general definition is as follows: a filter <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">:</span> <span class="pre">filter</span> <span class="pre">X</span></code> is a
collection of sets <code class="docutils literal notranslate"><span class="pre">F.sets</span> <span class="pre">:</span> <span class="pre">set</span> <span class="pre">(set</span> <span class="pre">X)</span></code> satisfying the following:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">F.univ_sets</span> <span class="pre">:</span> <span class="pre">univ</span> <span class="pre">&#8712;</span> <span class="pre">F.sets</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">F.sets_of_superset</span> <span class="pre">:</span> <span class="pre">&#8704;</span> <span class="pre">{U</span> <span class="pre">V},</span> <span class="pre">U</span> <span class="pre">&#8712;</span> <span class="pre">F.sets</span> <span class="pre">&#8594;</span> <span class="pre">U</span> <span class="pre">&#8838;</span> <span class="pre">V</span> <span class="pre">&#8594;</span> <span class="pre">V</span> <span class="pre">&#8712;</span> <span class="pre">F.sets</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">F.inter_sets</span> <span class="pre">:</span> <span class="pre">&#8704;</span> <span class="pre">{U</span> <span class="pre">V},</span> <span class="pre">U</span> <span class="pre">&#8712;</span> <span class="pre">sets</span> <span class="pre">&#8594;</span> <span class="pre">V</span> <span class="pre">&#8712;</span> <span class="pre">sets</span> <span class="pre">&#8594;</span> <span class="pre">U</span> <span class="pre">&#8745;</span> <span class="pre">V</span> <span class="pre">&#8712;</span> <span class="pre">sets</span></code>.</p></li>
</ul>
<p>The first condition says that the set of all elements of <code class="docutils literal notranslate"><span class="pre">X</span></code> belongs to <code class="docutils literal notranslate"><span class="pre">F.sets</span></code>.
The second condition says that if <code class="docutils literal notranslate"><span class="pre">U</span></code> belongs to <code class="docutils literal notranslate"><span class="pre">F.sets</span></code> then anything
containing <code class="docutils literal notranslate"><span class="pre">U</span></code> also belongs to <code class="docutils literal notranslate"><span class="pre">F.sets</span></code>.
The third condition says that <code class="docutils literal notranslate"><span class="pre">F.sets</span></code> is closed under finite intersections.
In mathlib, a filter <code class="docutils literal notranslate"><span class="pre">F</span></code> is defined to be a structure bundling <code class="docutils literal notranslate"><span class="pre">F.sets</span></code> and its
three properties, but the properties carry no additional data,
and it is convenient to blur the distinction between <code class="docutils literal notranslate"><span class="pre">F</span></code> and <code class="docutils literal notranslate"><span class="pre">F.sets</span></code>. We
therefore define <code class="docutils literal notranslate"><span class="pre">U</span> <span class="pre">&#8712;</span> <span class="pre">F</span></code> to mean <code class="docutils literal notranslate"><span class="pre">U</span> <span class="pre">&#8712;</span> <span class="pre">F.sets</span></code>.
This explains why the word <code class="docutils literal notranslate"><span class="pre">sets</span></code> appears in the names of some lemmas that
that mention <code class="docutils literal notranslate"><span class="pre">U</span> <span class="pre">&#8712;</span> <span class="pre">F</span></code>.</p>
<p>It may help to think of a filter as defining a notion of a &#8220;sufficiently large&#8221; set. The first
condition then says that <code class="docutils literal notranslate"><span class="pre">univ</span></code> is sufficiently large, the second one says that a set containing a sufficiently
large set is sufficiently large and the third one says that the intersection of two sufficiently large sets
is sufficiently large.</p>
<p>It may be even  more useful to think of a filter on a type <code class="docutils literal notranslate"><span class="pre">X</span></code>
as a generalized element of <code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">X</span></code>. For instance, <code class="docutils literal notranslate"><span class="pre">at_top</span></code> is the
&#8220;set of very large numbers&#8221; and <code class="docutils literal notranslate"><span class="pre">&#120029;</span> <span class="pre">x&#8320;</span></code> is the &#8220;set of points very close to <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code>.&#8221;
One manifestation of this view is that we can associate to any <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">:</span> <span class="pre">set</span> <span class="pre">X</span></code> the so-called <em>principal filter</em>
consisting of all sets that contain <code class="docutils literal notranslate"><span class="pre">s</span></code>.
This definition is already in mathlib and has a notation <code class="docutils literal notranslate"><span class="pre">&#120031;</span></code> (localized in the <code class="docutils literal notranslate"><span class="pre">filter</span></code> namespace).
For the purpose of demonstration, we ask you to take this opportunity to work out the definition here.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">principal</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">&#945;</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">sets</span> <span class="o">:=</span> <span class="o">{</span><span class="n">t</span> <span class="bp">|</span> <span class="n">s</span> <span class="bp">&#8838;</span> <span class="n">t</span><span class="o">},</span>
  <span class="n">univ_sets</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">sets_of_superset</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">inter_sets</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">}</span>
</pre></div>
</div>
<p>For our second example, we ask you to define the filter <code class="docutils literal notranslate"><span class="pre">at_top</span> <span class="pre">:</span> <span class="pre">filter</span> <span class="pre">&#8469;</span></code>.
(We could use any type with a preorder instead of <code class="docutils literal notranslate"><span class="pre">&#8469;</span></code>.)</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">&#8469;</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">sets</span> <span class="o">:=</span> <span class="o">{</span><span class="n">s</span> <span class="bp">|</span> <span class="bp">&#8707;</span> <span class="n">a</span><span class="o">,</span> <span class="bp">&#8704;</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="bp">&#8804;</span> <span class="n">b</span> <span class="bp">&#8594;</span> <span class="n">b</span> <span class="bp">&#8712;</span> <span class="n">s</span><span class="o">},</span>
  <span class="n">univ_sets</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">sets_of_superset</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">inter_sets</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="o">}</span>
</pre></div>
</div>
<p>We can also directly define the filter <code class="docutils literal notranslate"><span class="pre">&#120029;</span> <span class="pre">x</span></code> of neighborhoods of any <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">&#8477;</span></code>.
In the real numbers, a neighborhood of <code class="docutils literal notranslate"><span class="pre">x</span></code> is a set containing an open interval
<span class="math notranslate nohighlight">\((x_0 - \varepsilon, x_0 + \varepsilon)\)</span>,
defined in mathlib as <code class="docutils literal notranslate"><span class="pre">Ioo</span> <span class="pre">(x&#8320;</span> <span class="pre">-</span> <span class="pre">&#949;)</span> <span class="pre">(x&#8320;</span> <span class="pre">+</span> <span class="pre">&#949;)</span></code>.
(This is notion of a neighborhood is only a special case of a more general construction in mathlib.)</p>
<p>With these examples, we can already define what is means for a function <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">X</span> <span class="pre">&#8594;</span> <span class="pre">Y</span></code>
to converge to some <code class="docutils literal notranslate"><span class="pre">G</span> <span class="pre">:</span> <span class="pre">filter</span> <span class="pre">Y</span></code> along some <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">:</span> <span class="pre">filter</span> <span class="pre">X</span></code>,
as follows:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">tendsto&#8321;</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">&#8704;</span> <span class="n">V</span> <span class="bp">&#8712;</span> <span class="n">G</span><span class="o">,</span> <span class="n">f</span> <span class="bp">&#8315;&#185;&#39;</span> <span class="n">V</span> <span class="bp">&#8712;</span> <span class="n">F</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">X</span></code> is <code class="docutils literal notranslate"><span class="pre">&#8469;</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> is <code class="docutils literal notranslate"><span class="pre">&#8477;</span></code>, <code class="docutils literal notranslate"><span class="pre">tendsto&#8321;</span> <span class="pre">u</span> <span class="pre">at_top</span> <span class="pre">(&#120029;</span> <span class="pre">x)</span></code> is equivalent to saying that the sequence <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">:</span> <span class="pre">&#8469;</span> <span class="pre">&#8594;</span> <span class="pre">&#8477;</span></code>
converges to the real number <code class="docutils literal notranslate"><span class="pre">x</span></code>. When both <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> are <code class="docutils literal notranslate"><span class="pre">&#8477;</span></code>, <code class="docutils literal notranslate"><span class="pre">tendsto</span> <span class="pre">f</span> <span class="pre">(&#120029;</span> <span class="pre">x&#8320;)</span> <span class="pre">(&#120029;</span> <span class="pre">y&#8320;)</span></code>
is equivalent to the familiar notion <span class="math notranslate nohighlight">\(\lim_{x \to x&#8320;} f(x) = y&#8320;\)</span>.
All of the other kinds of limits mentioned in the introduction are
also equivalent to instances of <code class="docutils literal notranslate"><span class="pre">tendsto&#8321;</span></code> for suitable choices of filters on the source and target.</p>
<p>The notion <code class="docutils literal notranslate"><span class="pre">tendsto&#8321;</span></code> above is definitionally equivalent to the notion <code class="docutils literal notranslate"><span class="pre">tendsto</span></code> that is defined in mathlib,
but the latter is defined more abstractly.
The problem with the definition of <code class="docutils literal notranslate"><span class="pre">tendsto&#8321;</span></code> is that it exposes a quantifier and elements of <code class="docutils literal notranslate"><span class="pre">G</span></code>,
and it hides the intuition that we get by viewing filters as generalized sets. We can
hide the quantifier <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">V</span></code> and make the intuition more salient by using more algebraic and set-theoretic machinery.
The first ingredient is the <em>pushforward</em> operation <span class="math notranslate nohighlight">\(f_*\)</span> associated to any map <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">X</span> <span class="pre">&#8594;</span> <span class="pre">Y</span></code>,
denoted <code class="docutils literal notranslate"><span class="pre">filter.map</span> <span class="pre">f</span></code> in mathlib. Given a filter <code class="docutils literal notranslate"><span class="pre">F</span></code> on <code class="docutils literal notranslate"><span class="pre">X</span></code>, <code class="docutils literal notranslate"><span class="pre">filter.map</span> <span class="pre">f</span> <span class="pre">F</span> <span class="pre">:</span> <span class="pre">filter</span> <span class="pre">Y</span></code> is defined so that
<code class="docutils literal notranslate"><span class="pre">V</span> <span class="pre">&#8712;</span> <span class="pre">filter.map</span> <span class="pre">f</span> <span class="pre">F</span> <span class="pre">&#8596;</span> <span class="pre">f</span> <span class="pre">&#8315;&#185;'</span> <span class="pre">V</span> <span class="pre">&#8712;</span> <span class="pre">F</span></code> holds definitionally.
In this examples file we&#8217;ve opened the <code class="docutils literal notranslate"><span class="pre">filter</span></code> namespace so that
<code class="docutils literal notranslate"><span class="pre">filter.map</span></code> can be written as <code class="docutils literal notranslate"><span class="pre">map</span></code>. This means that we can rewrite the definition of <code class="docutils literal notranslate"><span class="pre">tendsto</span></code> using
the order relation on <code class="docutils literal notranslate"><span class="pre">filter</span> <span class="pre">Y</span></code>, which is reversed inclusion of the set of members.
In other words, given <code class="docutils literal notranslate"><span class="pre">G</span> <span class="pre">H</span> <span class="pre">:</span> <span class="pre">filter</span> <span class="pre">Y</span></code>, we have <code class="docutils literal notranslate"><span class="pre">G</span> <span class="pre">&#8804;</span> <span class="pre">H</span> <span class="pre">&#8596;</span> <span class="pre">&#8704;</span> <span class="pre">V</span> <span class="pre">:</span> <span class="pre">set</span> <span class="pre">Y,</span> <span class="pre">V</span> <span class="pre">&#8712;</span> <span class="pre">H</span> <span class="pre">&#8594;</span> <span class="pre">V</span> <span class="pre">&#8712;</span> <span class="pre">G</span></code>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">tendsto&#8322;</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">map</span> <span class="n">f</span> <span class="n">F</span> <span class="bp">&#8804;</span> <span class="n">G</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">tendsto&#8322;</span> <span class="n">f</span> <span class="n">F</span> <span class="n">G</span> <span class="bp">&#8596;</span> <span class="n">tendsto&#8321;</span> <span class="n">f</span> <span class="n">F</span> <span class="n">G</span> <span class="o">:=</span> <span class="n">iff.rfl</span>
</pre></div>
</div>
<p>It may seem that the order relation on filters is backward. But recall that we can view filters on <code class="docutils literal notranslate"><span class="pre">X</span></code> as
generalized elements of <code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">X</span></code>, via the inclusion of <code class="docutils literal notranslate"><span class="pre">&#120031;</span> <span class="pre">:</span> <span class="pre">set</span> <span class="pre">X</span> <span class="pre">&#8594;</span> <span class="pre">filter</span> <span class="pre">X</span></code> which maps any set <code class="docutils literal notranslate"><span class="pre">s</span></code> to the corresponding principal filter.
This inclusion is order preserving, so the order relation on <code class="docutils literal notranslate"><span class="pre">filter</span></code> can indeed be seen as the natural inclusion relation
between generalized sets. In this analogy, pushforward is analogous to the direct image.
And, indeed, <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">f</span> <span class="pre">(&#120031;</span> <span class="pre">s)</span> <span class="pre">=</span> <span class="pre">&#120031;</span> <span class="pre">(f</span> <span class="pre">''</span> <span class="pre">s)</span></code>.</p>
<p>We can now understand intuitively why a sequence <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">:</span> <span class="pre">&#8469;</span> <span class="pre">&#8594;</span> <span class="pre">&#8477;</span></code> converges to
a point <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code> if and only if we have <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">u</span> <span class="pre">at_top</span> <span class="pre">&#8804;</span> <span class="pre">&#120029;</span> <span class="pre">x&#8320;</span></code>.
The inequality means the &#8220;direct image under <code class="docutils literal notranslate"><span class="pre">u</span></code>&#8221; of
&#8220;the set of very big natural numbers&#8221; is &#8220;included&#8221; in &#8220;the set of points very close to <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code>.&#8221;</p>
<p>As promised, the definition of <code class="docutils literal notranslate"><span class="pre">tendsto&#8322;</span></code> does not exhibit any quantifiers or sets.
It also leverages the algebraic properties of the pushforward operation.
First, each <code class="docutils literal notranslate"><span class="pre">filter.map</span> <span class="pre">f</span></code> is monotone. And, second, <code class="docutils literal notranslate"><span class="pre">filter.map</span></code> is compatible with
composition.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="o">(</span><span class="bp">@</span><span class="n">filter.map_mono</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">{</span><span class="n">&#945;</span> <span class="n">&#946;</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span><span class="o">},</span> <span class="n">monotone</span> <span class="o">(</span><span class="n">map</span> <span class="n">m</span><span class="o">))</span>
<span class="k">#check</span> <span class="o">(</span><span class="bp">@</span><span class="n">filter.map_map</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">{</span><span class="n">&#945;</span> <span class="n">&#946;</span> <span class="n">&#947;</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">&#945;</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span><span class="o">}</span> <span class="o">{</span><span class="n">m&#39;</span> <span class="o">:</span> <span class="n">&#946;</span> <span class="bp">&#8594;</span> <span class="n">&#947;</span><span class="o">},</span>
                            <span class="n">map</span> <span class="n">m&#39;</span> <span class="o">(</span><span class="n">map</span> <span class="n">m</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="n">map</span> <span class="o">(</span><span class="n">m&#39;</span> <span class="bp">&#8728;</span> <span class="n">m</span><span class="o">)</span> <span class="n">f</span><span class="o">)</span>
</pre></div>
</div>
<p>Together these two properties allow us to prove that limits compose, yielding in one shot all 256 variants
of the composition lemma described in the introduction, and lots more.
You can practice proving the following statement using either the definition
of <code class="docutils literal notranslate"><span class="pre">tendsto&#8321;</span></code> in terms of the
universal quantifier or the algebraic definition,
together with the two lemmas above.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Y</span><span class="o">}</span> <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Z</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">&#8594;</span> <span class="n">Z</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">tendsto&#8321;</span> <span class="n">f</span> <span class="n">F</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">tendsto&#8321;</span> <span class="n">g</span> <span class="n">G</span> <span class="n">H</span><span class="o">)</span> <span class="o">:</span> <span class="n">tendsto&#8321;</span> <span class="o">(</span><span class="n">g</span> <span class="bp">&#8728;</span> <span class="n">f</span><span class="o">)</span> <span class="n">F</span> <span class="n">H</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</pre></div>
</div>
<p>The pushforward construction uses a map to push filters from the map source to the map target.
There also a <em>pullback</em> operation, <code class="docutils literal notranslate"><span class="pre">filter.comap</span></code>, going in the other direction.
This generalizes the
preimage operation on sets. For any map <code class="docutils literal notranslate"><span class="pre">f</span></code>,
<code class="docutils literal notranslate"><span class="pre">filter.map</span> <span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">filter.comap</span> <span class="pre">f</span></code> form what is known as a <em>Galois connection</em>,
which is to say, they satisfy</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">filter.map_le_iff_le_comap</span> <span class="pre">:</span> <span class="pre">filter.map</span> <span class="pre">f</span> <span class="pre">F</span> <span class="pre">&#8804;</span> <span class="pre">G</span> <span class="pre">&#8596;</span> <span class="pre">F</span> <span class="pre">&#8804;</span> <span class="pre">filter.comap</span> <span class="pre">f</span> <span class="pre">G</span></code></p>
</div></blockquote>
<p>for every <code class="docutils literal notranslate"><span class="pre">F</span></code> and <code class="docutils literal notranslate"><span class="pre">G</span></code>.
This operation could be used to provided another formulation of <code class="docutils literal notranslate"><span class="pre">tendsto</span></code> that would be provably
(but not definitionaly) equivalent to the one in mathlib.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">comap</span></code> operation can be used to restrict filters to a subtype. For instance, suppose we have <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">&#8477;</span> <span class="pre">&#8594;</span> <span class="pre">&#8477;</span></code>,
<code class="docutils literal notranslate"><span class="pre">x&#8320;</span> <span class="pre">:</span> <span class="pre">&#8477;</span></code> and <code class="docutils literal notranslate"><span class="pre">y&#8320;</span> <span class="pre">:</span> <span class="pre">&#8477;</span></code>, and suppose we want to state that <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code> approaches <code class="docutils literal notranslate"><span class="pre">y&#8320;</span></code> when <code class="docutils literal notranslate"><span class="pre">x</span></code> approaches <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code> within the rational numbers.
We can pull the filter <code class="docutils literal notranslate"><span class="pre">&#120029;</span> <span class="pre">x&#8320;</span></code> back to <code class="docutils literal notranslate"><span class="pre">&#8474;</span></code> using the coercion map
<code class="docutils literal notranslate"><span class="pre">coe</span> <span class="pre">:</span> <span class="pre">&#8474;</span> <span class="pre">&#8594;</span> <span class="pre">&#8477;</span></code> and state <code class="docutils literal notranslate"><span class="pre">tendsto</span> <span class="pre">(f</span> <span class="pre">&#8728;</span> <span class="pre">coe</span> <span class="pre">:</span> <span class="pre">&#8474;</span> <span class="pre">&#8594;</span> <span class="pre">&#8477;)</span> <span class="pre">(comap</span> <span class="pre">coe</span> <span class="pre">(&#120029;</span> <span class="pre">x&#8320;))</span> <span class="pre">(&#120029;</span> <span class="pre">y&#8320;)</span></code>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variables</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#8477;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">(</span><span class="n">x&#8320;</span> <span class="n">y&#8320;</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">comap</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">&#8474;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">x&#8320;</span><span class="o">)</span>
<span class="k">#check</span> <span class="n">tendsto</span> <span class="o">(</span><span class="n">f</span> <span class="bp">&#8728;</span> <span class="n">coe</span><span class="o">)</span> <span class="o">(</span><span class="n">comap</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">&#8474;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">x&#8320;</span><span class="o">))</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">y&#8320;</span><span class="o">)</span>
</pre></div>
</div>
<p>The pullback operation is also compatible with composition, but it <em>contravariant</em>,
which is to say, it reverses the order of the arguments.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">section</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">&#945;</span> <span class="n">&#946;</span> <span class="n">&#947;</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">&#947;</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#946;</span> <span class="bp">&#8594;</span> <span class="n">&#945;</span><span class="o">}</span>

<span class="k">#check</span> <span class="o">(</span><span class="n">comap_comap</span> <span class="o">:</span> <span class="n">comap</span> <span class="n">m</span> <span class="o">(</span><span class="n">comap</span> <span class="n">n</span> <span class="n">F</span><span class="o">)</span> <span class="bp">=</span> <span class="n">comap</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&#8728;</span> <span class="n">m</span><span class="o">)</span> <span class="n">F</span><span class="o">)</span>
<span class="kd">end</span>
</pre></div>
</div>
<p>Let&#8217;s now shift attention to the plane <code class="docutils literal notranslate"><span class="pre">&#8477;</span> <span class="pre">&#215;</span> <span class="pre">&#8477;</span></code> and try to understand how the neighborhoods of a point
<code class="docutils literal notranslate"><span class="pre">(x&#8320;,</span> <span class="pre">y&#8320;)</span></code> are related to <code class="docutils literal notranslate"><span class="pre">&#120029;</span> <span class="pre">x&#8320;</span></code> and <code class="docutils literal notranslate"><span class="pre">&#120029;</span> <span class="pre">y&#8320;</span></code>. There is a product operation
<code class="docutils literal notranslate"><span class="pre">filter.prod</span> <span class="pre">:</span> <span class="pre">filter</span> <span class="pre">X</span> <span class="pre">&#8594;</span> <span class="pre">filter</span> <span class="pre">Y</span> <span class="pre">&#8594;</span> <span class="pre">filter</span> <span class="pre">(X</span> <span class="pre">&#215;</span> <span class="pre">Y)</span></code>, denoted by <code class="docutils literal notranslate"><span class="pre">&#215;&#7584;</span></code>, which answers this question:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="bp">&#120029;</span> <span class="o">(</span><span class="n">x&#8320;</span><span class="o">,</span> <span class="n">y&#8320;</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">&#120029;</span> <span class="n">x&#8320;</span> <span class="bp">&#215;&#7584;</span> <span class="bp">&#120029;</span> <span class="n">y&#8320;</span> <span class="o">:=</span> <span class="n">nhds_prod_eq</span>
</pre></div>
</div>
<p>The product operation is defined in terms of the pullback operation and the <code class="docutils literal notranslate"><span class="pre">inf</span></code> operation:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">&#215;&#7584;</span> <span class="pre">G</span> <span class="pre">=</span> <span class="pre">(comap</span> <span class="pre">prod.fst</span> <span class="pre">F)</span> <span class="pre">&#8851;</span> <span class="pre">(comap</span> <span class="pre">prod.snd</span> <span class="pre">G)</span></code>.</p>
</div></blockquote>
<p>Here the <code class="docutils literal notranslate"><span class="pre">inf</span></code> operation refers to the lattice structure on <code class="docutils literal notranslate"><span class="pre">filter</span> <span class="pre">X</span></code> for any type <code class="docutils literal notranslate"><span class="pre">X</span></code>, whereby
<code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">&#8851;</span> <span class="pre">G</span></code> is the greatest filter that is smaller than both <code class="docutils literal notranslate"><span class="pre">F</span></code> and <code class="docutils literal notranslate"><span class="pre">G</span></code>.
Thus the <code class="docutils literal notranslate"><span class="pre">inf</span></code> operation generalizes the notion of the intersection of sets.</p>
<p>A lot of proofs in mathlib use all of the aforementioned structure (<code class="docutils literal notranslate"><span class="pre">map</span></code>, <code class="docutils literal notranslate"><span class="pre">comap</span></code>, <code class="docutils literal notranslate"><span class="pre">inf</span></code>, <code class="docutils literal notranslate"><span class="pre">sup</span></code>, and <code class="docutils literal notranslate"><span class="pre">prod</span></code>)
to give algebraic proofs about convergence without ever referring to members of filters.
You can practice doing this in a proof of the following lemma, unfolding the definition of <code class="docutils literal notranslate"><span class="pre">tendsto</span></code>
and <code class="docutils literal notranslate"><span class="pre">filter.prod</span></code> if needed.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="n">le_inf_iff</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span> <span class="bp">&#215;</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">(</span><span class="n">x&#8320;</span> <span class="n">y&#8320;</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">tendsto</span> <span class="n">f</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="o">(</span><span class="n">x&#8320;</span><span class="o">,</span> <span class="n">y&#8320;</span><span class="o">))</span> <span class="bp">&#8596;</span>
    <span class="n">tendsto</span> <span class="o">(</span><span class="n">prod.fst</span> <span class="bp">&#8728;</span> <span class="n">f</span><span class="o">)</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">x&#8320;</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="n">tendsto</span> <span class="o">(</span><span class="n">prod.snd</span> <span class="bp">&#8728;</span> <span class="n">f</span><span class="o">)</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">y&#8320;</span><span class="o">)</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</pre></div>
</div>
<p>The ordered type <code class="docutils literal notranslate"><span class="pre">filter</span> <span class="pre">X</span></code> is actually a <em>complete</em> lattice,
which is to say, there is a bottom element, there is a top element, and
every set of filters on <code class="docutils literal notranslate"><span class="pre">X</span></code> has an <code class="docutils literal notranslate"><span class="pre">Inf</span></code> and a <code class="docutils literal notranslate"><span class="pre">Sup</span></code>.</p>
<p>Note that given the second property in the definition of a filter
(if <code class="docutils literal notranslate"><span class="pre">U</span></code> belongs to <code class="docutils literal notranslate"><span class="pre">F</span></code> then anything larger than <code class="docutils literal notranslate"><span class="pre">U</span></code> also belongs to <code class="docutils literal notranslate"><span class="pre">F</span></code>),
the first property
(the set of all inhabitants of <code class="docutils literal notranslate"><span class="pre">X</span></code> belongs to <code class="docutils literal notranslate"><span class="pre">F</span></code>) is
equivalent to the property that <code class="docutils literal notranslate"><span class="pre">F</span></code> is not the empty collection of sets.
This shouldn&#8217;t be confused with the more subtle question as to whether
the empty set is an <em>element</em> of <code class="docutils literal notranslate"><span class="pre">F</span></code>. The
definition of a filter does not prohibit <code class="docutils literal notranslate"><span class="pre">&#8709;</span> <span class="pre">&#8712;</span> <span class="pre">F</span></code>,
but if the empty set is in <code class="docutils literal notranslate"><span class="pre">F</span></code> then
every set is in <code class="docutils literal notranslate"><span class="pre">F</span></code>, which is to say, <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">U</span> <span class="pre">:</span> <span class="pre">set</span> <span class="pre">X,</span> <span class="pre">U</span> <span class="pre">&#8712;</span> <span class="pre">F</span></code>.
In this case, <code class="docutils literal notranslate"><span class="pre">F</span></code> is a rather trivial filter, which is precisely the
bottom element of the complete lattice <code class="docutils literal notranslate"><span class="pre">filter</span> <span class="pre">X</span></code>.
This contrasts with the definition of filters in
Bourbaki, which doesn&#8217;t allow filters containing the empty set.</p>
<p>Because we include the trivial filter in our definition, we sometimes need to explicitly assume
nontriviality in some lemmas.
In return, however, the theory has nicer global properties.
We have already seen that including the trivial filter gives us a
bottom element. It also allows us to define <code class="docutils literal notranslate"><span class="pre">principal</span> <span class="pre">:</span> <span class="pre">set</span> <span class="pre">X</span> <span class="pre">&#8594;</span> <span class="pre">filter</span> <span class="pre">X</span></code>,
which maps  <code class="docutils literal notranslate"><span class="pre">&#8709;</span></code> to <code class="docutils literal notranslate"><span class="pre">&#8869;</span></code>, without additing a precondition to rule out the empty set.
And it allows us to define the pullback operation without a precondition as well.
Indeed, it can happen that <code class="docutils literal notranslate"><span class="pre">comap</span> <span class="pre">f</span> <span class="pre">F</span> <span class="pre">=</span> <span class="pre">&#8869;</span></code> although <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">&#8800;</span> <span class="pre">&#8869;</span></code>. For instance,
given <code class="docutils literal notranslate"><span class="pre">x&#8320;</span> <span class="pre">:</span> <span class="pre">&#8477;</span></code> and <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">:</span> <span class="pre">set</span> <span class="pre">&#8477;</span></code>, the pullback of <code class="docutils literal notranslate"><span class="pre">&#120029;</span> <span class="pre">x&#8320;</span></code> under the coercion
from the subtype corresponding to <code class="docutils literal notranslate"><span class="pre">s</span></code> is nontrivial if and only if <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code> belongs to the
closure of <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p>
<p>In order to manage lemmas that do need to assume some filter is nontrivial, mathlib has
a type class <code class="docutils literal notranslate"><span class="pre">filter.ne_bot</span></code>, and the library has lemmas that assume
<code class="docutils literal notranslate"><span class="pre">(F</span> <span class="pre">:</span> <span class="pre">filter</span> <span class="pre">X)</span> <span class="pre">[F.ne_bot]</span></code>. The instance database knows, for example, that <code class="docutils literal notranslate"><span class="pre">(at_top</span> <span class="pre">:</span> <span class="pre">filter</span> <span class="pre">&#8469;).ne_bot</span></code>,
and it knows that pushing forward a nontrivial filter gives a nontrivial filter.
As a result, a lemma assuming <code class="docutils literal notranslate"><span class="pre">[F.ne_bot]</span></code> will automatically apply to <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">u</span> <span class="pre">at_top</span></code> for any sequence <code class="docutils literal notranslate"><span class="pre">u</span></code>.</p>
<p>Our tour of the algebraic properties of filters and their relation to limits is essentially done,
but we have not yet justified our claim to have recaptured the usual limit notions.
Superficially, it may seem that <code class="docutils literal notranslate"><span class="pre">tendsto</span> <span class="pre">u</span> <span class="pre">at_top</span> <span class="pre">(&#120029;</span> <span class="pre">x&#8320;)</span></code>
is stronger than the notion of convergence defined in <a class="reference internal" href="03_Logic.html#sequences-and-convergence"><span class="std std-numref">Section 3.6</span></a> because we ask that <em>every</em> neighborhood of <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code>
has a preimage belonging to <code class="docutils literal notranslate"><span class="pre">at_top</span></code>, whereas the usual definition only requires
this for the standard neighborhoods <code class="docutils literal notranslate"><span class="pre">Ioo</span> <span class="pre">(x&#8320;</span> <span class="pre">-</span> <span class="pre">&#949;)</span> <span class="pre">(x&#8320;</span> <span class="pre">+</span> <span class="pre">&#949;)</span></code>.
The key is that, by definition, every neighborhood contains such a standard one.
This observation leads to the notion of a <em>filter basis</em>.</p>
<p>Given <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">:</span> <span class="pre">filter</span> <span class="pre">X</span></code>,
a family of sets <cite>s : &#953; &#8594; set X</cite> is a basis for <code class="docutils literal notranslate"><span class="pre">F</span></code> if for every set <code class="docutils literal notranslate"><span class="pre">U</span></code>,
we have <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">i</span> <span class="pre">&#8838;</span> <span class="pre">U</span></code> for some <code class="docutils literal notranslate"><span class="pre">i</span></code>. In other words, formally speaking,
<code class="docutils literal notranslate"><span class="pre">s</span></code> is a basis if it satisfies
<code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">U</span> <span class="pre">:</span> <span class="pre">set</span> <span class="pre">X,</span> <span class="pre">U</span> <span class="pre">&#8712;</span> <span class="pre">F</span> <span class="pre">&#8596;</span> <span class="pre">&#8707;</span> <span class="pre">i,</span> <span class="pre">s</span> <span class="pre">i</span> <span class="pre">&#8838;</span> <span class="pre">U</span></code>. It is even more flexible to consider
a predicate on <code class="docutils literal notranslate"><span class="pre">&#953;</span></code> that selects only some of the values <code class="docutils literal notranslate"><span class="pre">i</span></code> in the indexing type.
In the case of <code class="docutils literal notranslate"><span class="pre">&#120029;</span> <span class="pre">x&#8320;</span></code>, we want <code class="docutils literal notranslate"><span class="pre">&#953;</span></code> to be <code class="docutils literal notranslate"><span class="pre">&#8477;</span></code>, we write <code class="docutils literal notranslate"><span class="pre">&#949;</span></code> for <code class="docutils literal notranslate"><span class="pre">i</span></code>, and the predicate should select the positive values of <code class="docutils literal notranslate"><span class="pre">&#949;</span></code>.
So the fact that the sets <code class="docutils literal notranslate"><span class="pre">Ioo</span>&#160; <span class="pre">(x&#8320;</span> <span class="pre">-</span> <span class="pre">&#949;)</span> <span class="pre">(x&#8320;</span> <span class="pre">+</span> <span class="pre">&#949;)</span></code> form a basis for the
neighborhood topology on <code class="docutils literal notranslate"><span class="pre">&#8477;</span></code> is stated as follows:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">x&#8320;</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_basis</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">x&#8320;</span><span class="o">)</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">&#949;</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">&#949;</span><span class="o">)</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">&#949;</span><span class="o">,</span> <span class="n">Ioo</span> <span class="o">(</span><span class="n">x&#8320;</span> <span class="bp">-</span> <span class="n">&#949;</span><span class="o">)</span> <span class="o">(</span><span class="n">x&#8320;</span> <span class="bp">+</span> <span class="n">&#949;</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">nhds_basis_Ioo_pos</span> <span class="n">x&#8320;</span>
</pre></div>
</div>
<p>There is also a nice basis for the filter <code class="docutils literal notranslate"><span class="pre">at_top</span></code>. The lemma
<code class="docutils literal notranslate"><span class="pre">filter.has_basis.tendsto_iff</span></code> allows
us to reformulate a statement of the form <code class="docutils literal notranslate"><span class="pre">tendsto</span> <span class="pre">f</span> <span class="pre">F</span> <span class="pre">G</span></code>
given bases for <code class="docutils literal notranslate"><span class="pre">F</span></code> and <code class="docutils literal notranslate"><span class="pre">G</span></code>.
Putting these pieces together gives us essentially the notion of convergence
that we used in <a class="reference internal" href="03_Logic.html#sequences-and-convergence"><span class="std std-numref">Section 3.6</span></a>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">(</span><span class="n">x&#8320;</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">tendsto</span> <span class="n">u</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">x&#8320;</span><span class="o">)</span> <span class="bp">&#8596;</span> <span class="bp">&#8704;</span> <span class="n">&#949;</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">&#8707;</span> <span class="n">N</span><span class="o">,</span> <span class="bp">&#8704;</span> <span class="n">n</span> <span class="bp">&#8805;</span> <span class="n">N</span><span class="o">,</span> <span class="n">u</span> <span class="n">n</span> <span class="bp">&#8712;</span> <span class="n">Ioo</span> <span class="o">(</span><span class="n">x&#8320;</span> <span class="bp">-</span> <span class="n">&#949;</span><span class="o">)</span> <span class="o">(</span><span class="n">x&#8320;</span> <span class="bp">+</span> <span class="n">&#949;</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">at_top.has_basis</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span> <span class="n">Ici</span> <span class="o">:=</span> <span class="n">at_top_basis</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">this.tendsto_iff</span> <span class="o">(</span><span class="n">nhds_basis_Ioo_pos</span> <span class="n">x&#8320;</span><span class="o">),</span>
  <span class="n">simp</span>
<span class="kd">end</span>
</pre></div>
</div>
<p>We now show how filters facilitate working with properties that hold for sufficiently large numbers
or for points that are sufficiently close to a given point. In <a class="reference internal" href="03_Logic.html#sequences-and-convergence"><span class="std std-numref">Section 3.6</span></a>, we were often faced with the situation where
we knew that some property <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">n</span></code> holds for sufficiently large <code class="docutils literal notranslate"><span class="pre">n</span></code> and that some
other property <code class="docutils literal notranslate"><span class="pre">Q</span> <span class="pre">n</span></code> holds for sufficiently large <code class="docutils literal notranslate"><span class="pre">n</span></code>.
Using <code class="docutils literal notranslate"><span class="pre">cases</span></code> twice gave us <code class="docutils literal notranslate"><span class="pre">N_P</span></code> and <code class="docutils literal notranslate"><span class="pre">N_Q</span></code> satisfying
<code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">n</span> <span class="pre">&#8805;</span> <span class="pre">N_P,</span> <span class="pre">P</span> <span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">n</span> <span class="pre">&#8805;</span> <span class="pre">N_Q,</span> <span class="pre">Q</span> <span class="pre">n</span></code>. Using <code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">N</span> <span class="pre">:=</span> <span class="pre">max</span> <span class="pre">N_P</span> <span class="pre">N_Q</span></code>, we could
eventually prove <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">n</span> <span class="pre">&#8805;</span> <span class="pre">N,</span> <span class="pre">P</span> <span class="pre">n</span> <span class="pre">&#8743;</span> <span class="pre">Q</span> <span class="pre">n</span></code>.
Doing this repeatedly becomes tiresome.</p>
<p>We can do better by noting that the statement &#8220;<code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span> <span class="pre">n</span></code> hold for large enough <code class="docutils literal notranslate"><span class="pre">n</span></code>&#8221; means
that we have <code class="docutils literal notranslate"><span class="pre">{n</span> <span class="pre">|</span> <span class="pre">P</span> <span class="pre">n}</span> <span class="pre">&#8712;</span> <span class="pre">at_top</span></code> and <code class="docutils literal notranslate"><span class="pre">{n</span> <span class="pre">|</span> <span class="pre">Q</span> <span class="pre">n}</span> <span class="pre">&#8712;</span> <span class="pre">at_top</span></code>.
The fact that <code class="docutils literal notranslate"><span class="pre">at_top</span></code> is a filter implies that the intersection of two elements of <code class="docutils literal notranslate"><span class="pre">at_top</span></code>
is again in <code class="docutils literal notranslate"><span class="pre">at_top</span></code>, so we have <code class="docutils literal notranslate"><span class="pre">{n</span> <span class="pre">|</span> <span class="pre">P</span> <span class="pre">n</span> <span class="pre">&#8743;</span> <span class="pre">Q</span> <span class="pre">n}</span> <span class="pre">&#8712;</span> <span class="pre">at_top</span></code>.
Writing <code class="docutils literal notranslate"><span class="pre">{n</span> <span class="pre">|</span> <span class="pre">P</span> <span class="pre">n}</span> <span class="pre">&#8712;</span> <span class="pre">at_top</span></code> is unpleasant,
but we can use the more suggestive notation <code class="docutils literal notranslate"><span class="pre">&#8704;&#7584;</span> <span class="pre">n</span> <span class="pre">in</span> <span class="pre">at_top,</span> <span class="pre">P</span> <span class="pre">n</span></code>.
Here the superscripted <code class="docutils literal notranslate"><span class="pre">f</span></code> stands for &#8220;filter.&#8221;
You can think of the notation as saying that for all <code class="docutils literal notranslate"><span class="pre">n</span></code> in the &#8220;set of very large numbers,&#8221; <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">n</span></code> holds. The <code class="docutils literal notranslate"><span class="pre">&#8704;&#7584;''</span>
<span class="pre">notation</span> <span class="pre">stands</span> <span class="pre">for</span> <span class="pre">``filter.eventually</span></code>, and the lemma <code class="docutils literal notranslate"><span class="pre">filter.eventually.and</span></code> uses the intersection property of filters to do what we just described:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hP</span> <span class="o">:</span> <span class="bp">&#8704;&#7584;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">hQ</span> <span class="o">:</span> <span class="bp">&#8704;&#7584;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">Q</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">&#8704;&#7584;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span> <span class="bp">&#8743;</span> <span class="n">Q</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">hP.and</span> <span class="n">hQ</span>
</pre></div>
</div>
<p>This notation is so convenient and intuitive that we also have specializations
when <code class="docutils literal notranslate"><span class="pre">P</span></code> is an equality or inequality statement. For example, let <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span></code> be
two sequences of real numbers, and let us show that if
<code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">n</span></code> coincide for sufficiently large <code class="docutils literal notranslate"><span class="pre">n</span></code> then
<code class="docutils literal notranslate"><span class="pre">u</span></code> tends to <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code> if and only if <code class="docutils literal notranslate"><span class="pre">v</span></code> tends to <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code>.
First we&#8217;ll use the generic <code class="docutils literal notranslate"><span class="pre">eventually</span></code> and then the one
specialized for the equality predicate, <code class="docutils literal notranslate"><span class="pre">eventually_eq</span></code>. The two statements are
definitionaly equivalent so the same proof work in both cases.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#8704;&#7584;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">u</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">v</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">x&#8320;</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">tendsto</span> <span class="n">u</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">x&#8320;</span><span class="o">)</span> <span class="bp">&#8596;</span> <span class="n">tendsto</span> <span class="n">v</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">x&#8320;</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">tendsto_congr&#39;</span> <span class="n">h</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">u</span> <span class="bp">=&#7584;</span><span class="o">[</span><span class="n">at_top</span><span class="o">]</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">x&#8320;</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">tendsto</span> <span class="n">u</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">x&#8320;</span><span class="o">)</span> <span class="bp">&#8596;</span> <span class="n">tendsto</span> <span class="n">v</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">x&#8320;</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">tendsto_congr&#39;</span> <span class="n">h</span>
</pre></div>
</div>
<p>It instructive to review the definition of filters in terms of <code class="docutils literal notranslate"><span class="pre">eventually</span></code>.
Given <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">:</span> <span class="pre">filter</span> <span class="pre">X</span></code>, for any predicates <code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span></code> on <code class="docutils literal notranslate"><span class="pre">X</span></code>,</p>
<ul class="simple">
<li><p>the condition <code class="docutils literal notranslate"><span class="pre">univ</span> <span class="pre">&#8712;</span> <span class="pre">F</span></code> ensures <code class="docutils literal notranslate"><span class="pre">(&#8704;</span> <span class="pre">x,</span> <span class="pre">P</span> <span class="pre">x)</span> <span class="pre">&#8594;</span> <span class="pre">&#8704;&#7584;</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">F,</span> <span class="pre">P</span> <span class="pre">x</span></code>,</p></li>
<li><p>the condition <code class="docutils literal notranslate"><span class="pre">U</span> <span class="pre">&#8712;</span> <span class="pre">F</span> <span class="pre">&#8594;</span> <span class="pre">U</span> <span class="pre">&#8838;</span> <span class="pre">V</span> <span class="pre">&#8594;</span> <span class="pre">V</span> <span class="pre">&#8712;</span> <span class="pre">F</span></code> ensures <code class="docutils literal notranslate"><span class="pre">(&#8704;&#7584;</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">F,</span> <span class="pre">P</span> <span class="pre">x)</span> <span class="pre">&#8594;</span> <span class="pre">(&#8704;</span> <span class="pre">x,</span> <span class="pre">P</span> <span class="pre">x</span> <span class="pre">&#8594;</span> <span class="pre">Q</span> <span class="pre">x)</span> <span class="pre">&#8594;</span> <span class="pre">&#8704;&#7584;</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">F,</span> <span class="pre">Q</span> <span class="pre">x</span></code>, and</p></li>
<li><p>the condition <code class="docutils literal notranslate"><span class="pre">U</span> <span class="pre">&#8712;</span> <span class="pre">F</span> <span class="pre">&#8594;</span> <span class="pre">V</span> <span class="pre">&#8712;</span> <span class="pre">F</span> <span class="pre">&#8594;</span> <span class="pre">U</span> <span class="pre">&#8745;</span> <span class="pre">V</span> <span class="pre">&#8712;</span> <span class="pre">F</span></code> ensures <code class="docutils literal notranslate"><span class="pre">(&#8704;&#7584;</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">F,</span> <span class="pre">P</span> <span class="pre">x)</span> <span class="pre">&#8594;</span> <span class="pre">(&#8704;&#7584;</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">F,</span> <span class="pre">Q</span> <span class="pre">x)</span> <span class="pre">&#8594;</span> <span class="pre">&#8704;&#7584;</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">F,</span> <span class="pre">P</span> <span class="pre">x</span> <span class="pre">&#8743;</span> <span class="pre">Q</span> <span class="pre">x</span></code>.</p></li>
</ul>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="bp">@</span><span class="n">eventually_of_forall</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">eventually.mono</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">eventually.and</span>
</pre></div>
</div>
<p>The second item, corresponding to <code class="docutils literal notranslate"><span class="pre">eventually.mono</span></code>, supports nice ways
of using filters, especially when combined
with <code class="docutils literal notranslate"><span class="pre">eventually.and</span></code>. The <code class="docutils literal notranslate"><span class="pre">filter_upwards</span></code> tactic allows us to combine them.
Compare:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="n">R</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hP</span> <span class="o">:</span> <span class="bp">&#8704;&#7584;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">hQ</span> <span class="o">:</span> <span class="bp">&#8704;&#7584;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">Q</span> <span class="n">n</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hR</span> <span class="o">:</span> <span class="bp">&#8704;&#7584;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span> <span class="bp">&#8743;</span> <span class="n">Q</span> <span class="n">n</span> <span class="bp">&#8594;</span> <span class="n">R</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">&#8704;&#7584;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">R</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="o">(</span><span class="n">hP.and</span> <span class="o">(</span><span class="n">hQ.and</span> <span class="n">hR</span><span class="o">))</span><span class="bp">.</span><span class="n">mono</span><span class="o">,</span>
  <span class="n">rintros</span> <span class="n">n</span> <span class="o">&#10216;</span><span class="n">h</span><span class="o">,</span> <span class="n">h&#39;</span><span class="o">,</span> <span class="n">h&#39;&#39;</span><span class="o">&#10217;,</span>
  <span class="n">exact</span> <span class="n">h&#39;&#39;</span> <span class="o">&#10216;</span><span class="n">h</span><span class="o">,</span> <span class="n">h&#39;</span><span class="o">&#10217;</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="n">R</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hP</span> <span class="o">:</span> <span class="bp">&#8704;&#7584;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">hQ</span> <span class="o">:</span> <span class="bp">&#8704;&#7584;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">Q</span> <span class="n">n</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hR</span> <span class="o">:</span> <span class="bp">&#8704;&#7584;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span> <span class="bp">&#8743;</span> <span class="n">Q</span> <span class="n">n</span> <span class="bp">&#8594;</span> <span class="n">R</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">&#8704;&#7584;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">R</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">filter_upwards</span> <span class="o">[</span><span class="n">hP</span><span class="o">,</span> <span class="n">hQ</span><span class="o">,</span> <span class="n">hR</span><span class="o">],</span>
  <span class="n">intros</span> <span class="n">n</span> <span class="n">h</span> <span class="n">h&#39;</span> <span class="n">h&#39;&#39;</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h&#39;&#39;</span> <span class="o">&#10216;</span><span class="n">h</span><span class="o">,</span> <span class="n">h&#39;</span><span class="o">&#10217;</span>
<span class="kd">end</span>
</pre></div>
</div>
<p>Readers who know about measure theory will note that the filter <code class="docutils literal notranslate"><span class="pre">&#956;.ae</span></code> of sets whose complement has measure zero
(aka &#8220;the set consisting of almost every point&#8221;) is not very useful as the source or target of <code class="docutils literal notranslate"><span class="pre">tendsto</span></code>, but it can be conveniently
used with <code class="docutils literal notranslate"><span class="pre">eventually</span></code> to say that a property holds for almost every point.</p>
<p>There is a dual version of <code class="docutils literal notranslate"><span class="pre">&#8704;&#7584;</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">F,</span> <span class="pre">P</span> <span class="pre">x</span></code>, which is occasionally useful:
<code class="docutils literal notranslate"><span class="pre">&#8707;&#7584;</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">F,</span> <span class="pre">P</span> <span class="pre">x</span></code> means
<code class="docutils literal notranslate"><span class="pre">{x</span> <span class="pre">|</span> <span class="pre">&#172;P</span> <span class="pre">x}</span> <span class="pre">&#8713;</span> <span class="pre">f</span></code>. For example, <code class="docutils literal notranslate"><span class="pre">&#8707;&#7584;</span> <span class="pre">n</span> <span class="pre">in</span> <span class="pre">at_top,</span> <span class="pre">P</span> <span class="pre">n</span></code> means there are arbitrarily large <code class="docutils literal notranslate"><span class="pre">n</span></code> such that <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">n</span></code> holds.
The <code class="docutils literal notranslate"><span class="pre">&#8707;&#7584;</span></code> notation stands for <code class="docutils literal notranslate"><span class="pre">filter.frequently</span></code>.</p>
<p>For a more sophisticated example, consider the following statement about a sequence
<code class="docutils literal notranslate"><span class="pre">u</span></code>, a set <code class="docutils literal notranslate"><span class="pre">M</span></code>, and a value <code class="docutils literal notranslate"><span class="pre">x</span></code>:</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">u</span></code> converges to <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">n</span></code> belongs to <code class="docutils literal notranslate"><span class="pre">M</span></code> for
sufficiently large <code class="docutils literal notranslate"><span class="pre">n</span></code> then <code class="docutils literal notranslate"><span class="pre">x</span></code> is in the closure of <code class="docutils literal notranslate"><span class="pre">M</span></code>.</p>
</div></blockquote>
<p>This can be formalized as follows:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">tendsto</span> <span class="pre">u</span> <span class="pre">at_top</span> <span class="pre">(&#120029;</span> <span class="pre">x)</span> <span class="pre">&#8594;</span> <span class="pre">(&#8704;&#7584;</span> <span class="pre">n</span> <span class="pre">in</span> <span class="pre">at_top,</span> <span class="pre">u</span> <span class="pre">n</span> <span class="pre">&#8712;</span> <span class="pre">M)</span> <span class="pre">&#8594;</span> <span class="pre">x</span> <span class="pre">&#8712;</span> <span class="pre">closure</span> <span class="pre">M</span></code>.</p>
</div></blockquote>
<p>This is a special case of the theorem <code class="docutils literal notranslate"><span class="pre">mem_closure_of_tendsto</span></code> from the
topology library.
See if you can prove it using the quoted lemmas,
using the fact that <code class="docutils literal notranslate"><span class="pre">cluster_pt</span> <span class="pre">x</span> <span class="pre">F</span></code> means <code class="docutils literal notranslate"><span class="pre">(&#120029;</span> <span class="pre">x</span> <span class="pre">&#8851;</span> <span class="pre">F).ne_bot</span></code>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="n">mem_closure_iff_cluster_pt</span>
<span class="k">#check</span> <span class="n">le_principal_iff</span>
<span class="k">#check</span> <span class="n">ne_bot_of_le</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">set</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hux</span> <span class="o">:</span> <span class="n">tendsto</span> <span class="n">u</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">huM</span> <span class="o">:</span> <span class="bp">&#8704;&#7584;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">u</span> <span class="n">n</span> <span class="bp">&#8712;</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">closure</span> <span class="n">M</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="06_Abstract_Algebra.html" class="btn btn-neutral float-left" title="6. Abstract Algebra" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="genindex.html" class="btn btn-neutral float-right" title="Index" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Jeremy Avigad, Kevin Buzzard, Robert Y. Lewis, Patrick Massot.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>